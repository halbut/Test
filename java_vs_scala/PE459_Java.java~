import java.util.ArrayList;
import java.util.Arrays;

class PE459_Java {

    public static boolean debug = false;
    static boolean readFromFile = false;
    static boolean fastNimMult = true;

    static int[] row(int limit, ArrayList<Integer> V) {
	int[] R = new int[limit];
        R[0] = 1;
        int[] last = {1};
	for(int i=1; i < limit; i++) {
	    int[] cache = new int[V.size()];
	    ArrayList<Integer> mexList = new ArrayList<Integer>();
	    mexList.add(0);
	    for (int k=0; k < V.size(); k++) {
		if (V.get(k) > i+1)
		    break;
		int tmp_num = 0;
		if (V.get(k) == i+1) {               // starting a new size 
                    tmp_num = cache[k-1];             // use the last longest entry
		    for(int t=i-V.get(k)+1; t < i-V.get(k-1)+1; t++) {
			tmp_num ^= R[t];
		    }
		} else if (V.get(k) > 1) {
		    tmp_num = last[k];
		    tmp_num ^= R[i-V.get(k)];       // remove the first entry from last time
		    tmp_num ^= R[i-1];              // add the new entry
		}
		mexList.add(tmp_num);
		cache[k] = tmp_num;
	    }
	    int r = mex(mexList);
	    if (debug) System.out.println("nim_mult_str="+mexList+"  R("+i+") = "+r);
	    R[i] = r;
	    last = cache;
	}
	return R;
    }

    static int nim_sum(int a, int b) {
	return a^b;   // Computes binary XOR
    }

    static int mex(ArrayList<Integer> input) {
	// This function takes an input list of numbers and returns the mex value of those numbers
	// That is, the function returns the minimal exluded value (the smallest number, from 0, not in the list)
	// e.g. mex(List(0, 1, 3)) = 2   while   mex(List(0, 1, 2)) = 3 and mex(List(1, 2, 3)) = 0

	// use the array like a hash
	int[] numArr = new int[input.size()];

	//	System.out.print("Mex input List =");
	for (int i=0; i < input.size(); i++) {
	    //            System.out.print(input.get(i));
	    if (input.get(i) < input.size())     // no need to store large numbers
		numArr[input.get(i)] = 1;
	    //        print(numArr[i]+" ")
	}
	//	System.out.println();

	// Define n to be the largest number in our array
	int mexValue = -1;

	// Look for the numbers 0, 1, ..., n in the list of numbers
	// If any of those numbers are not in there, that is the mex value
	// If every number is contained in there, then the mex value is n+1
	for(int i=0; i < numArr.length; i++) {
	    if(numArr[i] != 1) {
		mexValue = i;
		break;
	    } else {
		mexValue = i+1;
	    }
	}
	return mexValue;
    }

    static int[][] nim_mult_cache;
    static long max_queried_nim_mult_cache = -2;


    static int nim_mult_partial(int a, int b) {
        max_queried_nim_mult_cache = Math.max(max_queried_nim_mult_cache, Math.max(a,b));
        if ((a >= nim_mult_cache.length) || (b >= nim_mult_cache[0].length)) {
    //            System.out.println("Extending nim_mult_cache to ("+a+","+b+")");
	    return nim_mult_slow(a,b);
	}

	return nim_mult_cache[a][b];
    }

    
    static long nim_mult(long a, long b) {
        max_queried_nim_mult_cache = Math.max(max_queried_nim_mult_cache, Math.max(a,b));

        if ((a < nim_mult_cache.length) && (b < nim_mult_cache[0].length)) {
	    if (nim_mult_cache[(int)a][(int)b] != -1)
		return (long)nim_mult_cache[(int)a][(int)b];
	}
	    
	long result = fastNimMult ? nim_mult_fast(a,b) : nim_mult_slow((int)a,(int)b) ;
        if ((a < nim_mult_cache.length) && (b < nim_mult_cache[0].length)) {
	    nim_mult_cache[(int)a][(int)b] = (int)result;
	}

	return result;
    }

/*
const ll ftp[6]={1ll<<1,1ll<<2,1ll<<4,1ll<<8,1ll<<16,1ll<<32}; // Fermat two-powers (2^(2^n))
ll nim_mul(ll x, ll y) {
  if (x>y) { // enforce x<=y
    ll t=x;
    x=y,y=t;
  }

  if (x==0) return 0;
  if (x==1) return y;

  ll ftpp=0; // Fermat two-power previous to y
  for (int i=0; i<sizeof(ftp)/sizeof(const ll); i++)
    if (ftp[i]==y) { // if y is a Fermat two-power use a rule
      if (x==y)
   return x*3/2;
      else
   return x*y;
    }
    else if (ftp[i]<y)
      ftpp=ftp[i];

  for (ll yy=1; yy<y; yy*=2)
    if (y&yy) // if y isn't a power of two reduce by distributive law
      return nim_mul(yy,x)^nim_mul(x,y-yy);
  if (x%ftpp) // avoid infinite recursion
    return nim_mul(ftpp,nim_mul(x,y/ftpp));
  return nim_mul(ftpp*3/2,nim_mul(x/ftpp,y/ftpp));
}
*/

    // Fermat two-powers (2^(2^n))
    static final long[] ftp = { 1L<<1, 1L<<2, 1L<<4, 1L<<8, 1L<<16, 1L<<32 }; 

    static long nim_mult_fast(long a, long b) {
	if (a>b) { // enforce a<=b
	    long t=a;
	    a=b;
	    b=t;
	}

	if (a==0) return 0;
	if (a==1) return b;

	long ftpp=0; // Fermat two-power previous to b
	for (int i=0; i < ftp.length; i++) {
	    if (ftp[i]==b) { // if b is a Fermat two-power use a rule
		if (a==b)
		    return 3*a/2;
		else
		    return a*b;
	    }
	    else if (ftp[i]<b)
		ftpp=ftp[i];
	}
	for (long bb=1; bb<b; bb*=2) {
	    if ((b&bb) != 0) // if b isn't a power of two reduce by distributive law
		return nim_mult(bb,a)^nim_mult(a, b-bb);
	}
	
	if (a%ftpp != 0) // avoid infinite recursion
	    return nim_mult(ftpp, nim_mult(a, b/ftpp));

	return nim_mult(ftpp*3/2, nim_mult(a/ftpp, b/ftpp));
    }

    static int nim_mult_slow(int a, int b) {
	// This function multiplies two nim values                                                                                                                                                 
        // Nim multiplication is defined recursively, so I have created an array of values and use those to build up to the desired value                                                          

	    // Determine the max of a and b, then create a square array of that size                                                                                                                   
	    int d = Math.max(a,b);

	    int[][] g =  new int[d+1][d+1];
	    for (int[] row : g)
		Arrays.fill(row, -1);  // Initialize the entire matrix as "-1"...this is used later to determine if we need to compute an entry or not                                                 
	    //  for(i <- 0 to d) {                                                                                                                                                                     
	    //    for(j <- 0 to d) {                                                                                                                                                                   
	    //      g[i][j]="-1"                                                                                                                                                                       
	    //    }                                                                                                                                                                                    
	    //  }                                                                                                                                                                                      

	    // Initialize the first two rows/columns of the matrix                                                                                                                                     
	    for (int i=0; i <= d; i++) {
		g[i][0] = 0;
		if (b>0)
		    g[i][1] = i;
	    }
	    for (int j=0; j <= d; j++) {
		g[0][j] = 0;
		if(a>0)
		    g[1][j] = j;
	    }

	    // Recursively determine the remaining values in the matrix                                                                                                                                
	    for(int m=2; m <= a; m++) {
		for(int n=2; n <= b; n++) {
		    // This helps to reduce the amount of calculations (it does a better reduction when a and b are close)                                                                             
		    if (g[m][n] == -1) {
			ArrayList<Integer> nim_mult_list = new ArrayList<Integer>();
			for(int k=0; k < m; k++) {
			    for(int l=0; l < n; l++) {
				int tmp_num = (g[m][l])^(g[k][n])^(g[k][l]);
				nim_mult_list.add(tmp_num);
			    }
			}
			g[m][n] = mex(nim_mult_list);
			g[n][m] = g[m][n];
		    }
		}
	    }
            nim_mult_cache = g;

        return nim_mult_cache[a-1][b-1];
    }

    static int nim_mult_generate(int a, int b) {
	// This function multiplies two nim values
	// Nim multiplication is defined recursively, so I have created an array of values and use those to build up to the desired value

	//	if ( (a < nim_mult_cache.length) && (b < nim_mult_cache[0].length) && (nim_mult_cache[a-1][b-1] != -1) ) 
	//	    return nim_mult_cache[a-1][b-1];

	// Determine the max of a and b, then create a square array of that size
	int d = Math.max(a,b);

//	nim_mult_cache =  new int[d+1][d+1];
//	for (int[] row : nim_mult_cache)
//	    Arrays.fill(row, -1);  // Initialize the entire matrix as "-1"...this is used later to determine if we need to compute an entry or not
	//  for(i <- 0 to d) {
	//    for(j <- 0 to d) {
	//      nim_mult_cache[i][j]="-1"
	//    }
	//  }

	// Initialize the first two rows/columns of the matrix
	for (int i=0; i <= d; i++) {
	    nim_mult_cache[i][0] = 0;
	    if (b>0)
		nim_mult_cache[i][1] = i;
	}
	for (int j=0; j <= d; j++) {
	    nim_mult_cache[0][j] = 0;
	    if(a>0)
		nim_mult_cache[1][j] = j;
	}

	// Recursively determine the remaining values in the matrix
	for(int m=2; m <= a; m++) {
            if (m%10==0) System.out.println("  nim_matrix computing row "+m);
	    for(int n=2; n <= b; n++) {
		// This helps to reduce the amount of calculations (it does a better reduction when a and b are close)
		if (nim_mult_cache[m][n] == -1) {
		    ArrayList<Integer> nim_mult_list = new ArrayList<Integer>();
		    for(int k=0; k < m; k++) {
			for(int l=0; l < n; l++) {
			    int tmp_num = (nim_mult_cache[m][l])^(nim_mult_cache[k][n])^(nim_mult_cache[k][l]);
			    nim_mult_list.add(tmp_num);
			}
		    }
		    nim_mult_cache[m][n] = mex(nim_mult_list);
		    nim_mult_cache[n][m] = nim_mult_cache[m][n];
		}
		//                nim_mult_cache[n][m] = nim_mult_cache[m][n];
		//		nim_mult_cache[m][n] = nim_mult_cache[n][m];
	    }
	}

	//	if ( (a < nim_mult_cache.length) && (b < nim_mult_cache[0].length)) {
	    //	    nim_mult_cache[a-1][b-1] = nim_mult_cache[a][b];
	    //	    nim_mult_cache[b-1][a-1] = nim_mult_cache[a][b];
	//	}

	// Return the desired multiplication value
	return nim_mult_cache[a][b];
    }

   static ArrayList<ArrayList<Integer>> generate(int limit) {

       ArrayList<Integer> W = new ArrayList<Integer>();
       ArrayList<Integer> H = new ArrayList<Integer>();

       for (int i=1; i <= 2*limit; i++) {
	   int w = i*i;
	   if (w <= limit)
	       W.add(w);
	   int h = (i+w)/2;
	   if (h > limit) 
	       break;
	   H.add(h);
       }
 
       ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
       result.add(W);
       result.add(H);

       return result;
   }

    static long[] getRanges(ArrayList<Integer> S, int[] V)  {
	long[] nRanges = new long[V.length+1];
	long[] ranges = new long[V.length+1];
	ranges[0] = 0;
	for (int n=1; n <= V.length; n++) {
	    ranges[n] = ranges[n-1]^V[n-1];
	    for (int s : S){
	    //              System.out.println("nRanges["+(ranges[n]^ranges[n-k])+"]++  (ranges["+n+"]="+ ranges[n] + "  ranges["+(n-k)+"]="+ranges[n-k] +")");
		if (s<=n) 
		    nRanges[(int)(ranges[n]^ranges[n-s])]++;
	    }
	    if (debug) {
		for (int i=0; i < ranges.length; i++) {
		    if (ranges[i] != 0)
			System.out.println("ranges["+i+"]="+ ranges[i]);
		}
	    }
	}
	if (debug) {
	    for (int i=0; i < nRanges.length; i++) {
		if (nRanges[i] != 0)
		    System.out.println("nRanges["+i+"]="+ nRanges[i]);
	    }
	}

	return nRanges;
    }

    static long findCount(int limit, long tot, ArrayList<ArrayList<Integer>> A, int[] R, int[] C, int[][] M)  {

	long[] nRow = getRanges(A.get(0), C);
	long[] nCol = getRanges(A.get(1), R);

//	for (int i=0; i <= limit; i++)
//	    if (nRow[i] != 0)
//		System.out.println("nRow["+i+"]="+ nRow[i]);
//
//	for (int i=0; i <= limit; i++)
//	    if (nCol[i] != 0)
//		System.out.println("nCol["+i+"]="+ nCol[i]);

	long count = 0;
	System.out.println("Calculating Solutions");
	for (int i=1; i <= limit; i++) {
//	    if (i%10000==0) System.out.println("  calculating solutions for i="+i);
	    if (nRow[i]==0)
		continue;
	    for (int j=1; j < limit; j++) {
		if (nCol[j] == 0) {
		    continue;
		}
		if (tot == (int)nim_mult(i,j)) {
		    long prod = (long)nRow[i]*(long)nCol[j];
		    System.out.println("i="+i+" j="+j+"  "+nRow[i]+" * "+ nCol[j] + " = " + prod + "   (total="+(count+prod)+")");
		    if (prod > 0) {
			count += prod;
		    }
		}
	    }
	}

	return count;
    }

    static int findCount2(int limit, long tot, ArrayList<ArrayList<Integer>> A, int[] R, int[] C, int[][] M)  {
	      //				    System.out.println("  a="+a+"  b="+b+"   M("+(n-a)+","+(m-b)+")="+M[n-a][m-b]);
	int count = 0;
	int nRows = A.get(1).size();
	int nColumns = A.get(0).size();
	for (int i=0; i < nRows; i++) {         // rows
	    int ARowi = A.get(1).get(i);
	    int lastLarge = 0;
	    System.out.println("findCount processing row "+ A.get(1).get(i));
	    for (int j=0; j < nColumns; j++) {  // columns
		int first = 0;
		int last = 0;
		int AColj = A.get(0).get(j);
		if (debug) System.out.println("Processing rectangle "+ ARowi +" x " + AColj);
		for (int n=ARowi-1; n < limit; n++) {
		    for (int m=AColj-1; m < limit; m++) {
			if (debug) System.out.println("   n="+n+"  m="+m+"   R("+i+")="+ARowi+"    C("+j+")="+AColj);
			int totR = 0;
			if ((n==ARowi-1) && (m==AColj-1)) {   // The first time we are doing the calculation
			    if (j==0) {
				if (debug) System.out.print("First time ever calculation                   totR=0");
				for (int a=0; a < ARowi; a++) {
				    for (int b=0; b < AColj; b++) {
					totR ^= nim_mult(R[n-a], C[m-b]);
//                                        if (debug) System.out.print("^"+M[n-a][m-b]);
				    }
				}
			    } else {
				if (debug) System.out.print("First time calculation                   totR=0^");
				totR ^= lastLarge;
                                if (debug) System.out.print("^"+lastLarge+"(c)");
				for (int a=0; a < ARowi; a++) {
				    for (int b=0; b < A.get(0).get(j)-A.get(0).get(j-1); b++) {
					totR ^= nim_mult(R[n-a], C[m-b]);
//                                        if (debug) System.out.print("^"+M[n-a][m-b]);
				    }
				}				
			    }
			    if (debug) System.out.println(" ="+totR);
			    first = totR;
			    lastLarge = first;
			} else {
			    if (m==AColj-1) {    // starting a new row
				if (debug) System.out.print("   Starting a new row, reusing first=" + first);
				totR = first;
				for (int b=0; b < AColj; b++) {        
				    totR ^= nim_mult(R[n-ARowi],C[m-b]); // remove the old bottom row
				    totR ^= nim_mult(R[n],C[m-b]);       // add the new top row
				}
                                first = totR;
			    } else {             // just moving to next column
				if (debug) System.out.print("      moving to the next column, reusing last=" + last);
				totR = last;
				for (int a=0; a < ARowi; a++) {
				    totR ^= nim_mult(R[n-a],C[m-AColj]); // remove the old left column
				    totR ^= nim_mult(R[n-a],C[m]);       // add the new right column 
				}
			    }
			}
			if (debug) System.out.println("    totR=" + totR);
			if (totR == tot) {
			    count += 1 ;
			    if (debug) System.out.println(count+") Found a solution in region: ("+n+","+m+") for shape ("+ARowi+","+AColj+")   totR="+totR);
			}
			last = totR;
		    }
		}
	    }
	}
	return count;
    }
    
    public static long[] puzzle_459(int limit) {
	System.out.println("======= Started 459 for limit=" + limit + " ========");
	nim_mult_cache = new int[10000+1][10000+1];
	for (int[] row : nim_mult_cache)
	    Arrays.fill(row, -1);

	System.out.println("Generating squares and triangle numbers");
	ArrayList<ArrayList<Integer>> A = generate(limit);

	System.out.println("Generating main row and column vectors");
	int[] C = row(limit,A.get(0));
	int[] R = row(limit,A.get(1));

	debug = false;
	if (debug) {
	    System.out.println("R=");
	    for(int i=0; i < R.length; i++) {
		System.out.print(R[i]+" ");
	    }
	    System.out.println();
	    System.out.println("C=");
	    for(int i=0; i < C.length; i++) {
		System.out.print(C[i]+" ");
	    }
	    System.out.println();
	}
	debug = false;

	// reversing so that the R[0] shows the bottom (this is just for convenience in visualizing)
	if (false) {
	    for(int i=0; i < R.length/2; i++) {
		int temp = R[i]; 
		R[i] = R[R.length - i - 1]; 
		R[R.length - i - 1] = temp; 
	    }
	}

        System.out.println("Calculating the score of the full matrix");

	long tot = 0;
	long totRow = 0;
	for (int r : R)
	    totRow ^= r;
	long totCol = 0;
	for (int c : C)
	    totCol ^= c;
	tot = nim_mult(totRow, totCol);
	System.out.println("nim_sum["+limit+"]="+tot);

	long count = (tot==0) ? 0: findCount(limit, tot, A, R, C, M);

	System.out.println("W("+limit+")="+count+"  Tot="+tot);
	long[] result = {count, tot};
        return result;
    }

    public static void main(String[] args) {
	int limit= 1000000; // 100 // 1000000
	System.out.println("W("+limit+")="+puzzle_459(limit)[0]);
        // Expected values:
        //    W(100)=31395 (tot=7)       W(300)=907144  (tot=11)        W(500)=72702  (tot=43)
	//    W(1000)=1869203 (tot=53)   W(10000)=2477885152 (tot=32)   W(100000)=2475200726993 (tot=186)
    }
}
