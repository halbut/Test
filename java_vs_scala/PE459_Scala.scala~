import scala.util.control.Breaks._

object PE459_Scala {

  type Vector = Array[Int]
  type Matrix = Array[Vector]

  def row(limit:Int,V:List[Int]) = {
//    print("Using V=")
//    for (i <- 0 to V.length-1)
//      print(V(i)+" ")
//    println()

    var R:Array[Int] = Array.fill(limit)(0)
//    R(0) = 1
    for(i <- 0 to limit-1) {
      var mexList:List[Int] = Nil
      mexList = 0 :: mexList
      breakable {
        for(k <- 0 to V.length-1) {
          if (V(k) > i+1)
            break
//          println("Computing i="+i+"  V("+k+")="+V(k))
          var tmp_num = 0
          for(t <- i-V(k)+1 to i-1) {
            tmp_num = nim_sum(tmp_num,R(t))
//            println("  Referenced i="+i+"  in R("+t+")="+R(t))
//            println("  Referenced i="+i+"  in R("+(i-V(k)+1)+")="+R(t))
          }
//          println("tmp_num="+tmp_num)
          mexList = tmp_num :: mexList
        }
      }
      var r = mex(mexList)
//      println("nim_mult_str="+nim_mult_str+"  R("+i+") = "+r)
      R(i) = r
     }
    R
  }

//   def matrix(Row:Array[Int],Col:Array[Int]) :Matrix = {
//     var M:Matrix =  Array.fill(Row.length, Col.length)(0)
//     for (i <- 0 to Row.length-1) {
//       for (j <- 0 to Col.length-1) {
//	 M(i)(j) = nim_mult(Row(i), Col(j))
//       }
//     }
//     M
//   }

   def nim_sum(a:Int, b:Int) = a^b // Computes binary XOR

   def mex(input:List[Int]) = {
   // This function takes an input list of numbers and returns the mex value of those numbers
   // That is, the function returns the minimal exluded value (the smallest number, from 0, not in the list)
   // e.g. mex(List(0, 1, 3)) = 2   while   mex(List(0, 1, 2)) = 3 and mex(List(1, 2, 3)) = 0

   // use the array like a hash
   var numArr = new Array[Int](input.length)

//   print("Mex input List =")
   for (i <- 0 to input.length-1) {
//     print(input(i))
     if (input(i) < input.length)  // no need to store large numbers
       numArr(input(i)) = 1
//     print(numArr(i)+" ")
   }
//   println()

   // Define n to be the largest number in our array
   var mexValue = -1

   // Look for the numbers 0, 1, ..., n in the list of numbers
   // If any of those numbers are not in there, that is the mex value
   // If every number is contained in there, then the mex value is n+1
   breakable {
     for(i <- 0 to numArr.length-1) {
       if(numArr(i) != 1) {
	 mexValue = i
	 break
       } else {
         mexValue = i+1
       }
     }
   }
   mexValue
 }

    // Fermat two-powers (2^(2^n))
    var ftp:List[Long] = List(2L, 4L, 16L, 256L, 65536L, 4294967296L)

    var nim_mult_cache:Matrix = Array.fill(1000, 1000)(-1)
    var max_queried_nim_mult_cache:Long = -2;


    def nim_mult(a:Long,b:Long):Long = {
        max_queried_nim_mult_cache = Math.max(max_queried_nim_mult_cache, Math.max(a,b))

        if ((a < nim_mult_cache.length) && (b < nim_mult_cache(0).length)) {
            if (nim_mult_cache(a.toInt)(b.toInt) != -1)
                return nim_mult_cache(a.toInt)(b.toInt)
        }

        var result:Long = nim_mult_fast(a.toInt,b.toInt)
        if ((a < nim_mult_cache.length) && (b < nim_mult_cache(0).length)) {
            nim_mult_cache(a.toInt)(b.toInt) = result.toInt
        }

        result
   }


   def nim_mult_fast(n1:Long,n2:Long):Long = {
      var a:Long = n1
      var b:Long = n2
      if (a>b) { // enforce a<=b                                                                                                         
         var t:Long=a
         a=b
         b=t
      }

      if (a==0) return 0;
      if (a==1) return b;

      var ftpp:Long = 0; // Fermat two-power previous to b                                                                                     

      for ( i <- 0 to ftp.length-1) {
            if (ftp(i)==b) { // if b is a Fermat two-power use a rule                                                                      
                if (a==b)
                    return 3*a/2
                else
                    return a*b
            } else if (ftp(i)<b) {
                ftpp=ftp(i)
            }
        }
//	println("ftpp="+ftpp+"     a="+a+"   b="+b)
        var bb:Long = 1
        while (bb < b) {
            if ((b&bb) != 0) { // if b isn't a power of two reduce by distributive law
//	        println("1) nim_mult("+bb+","+a+")"+"     a="+a+"   b="+b)
//	        println("2) nim_mult("+a+","+(b-bb)+")"+"     a="+a+"   b="+b)
                return nim_mult(bb,a)^nim_mult(a, b-bb);
            }
            bb *=2
        }

        if (a%ftpp != 0) { // avoid infinite recursion
//   	    println("3) nim_mult("+a+","+(b/ftpp)+")"+"     a="+a+"   b="+b)
//   	    println("4) nim_mult("+ftpp+",prev)"+"     a="+a+"   b="+b)
            return nim_mult(ftpp, nim_mult(a, b/ftpp));
        }
//      println("5) nim_mult("+(a/ftpp)+","+(b/ftpp)+")"+"     a="+a+"   b="+b)
//   	println("6) nim_mult("+(ftpp*3/2)+",prev)"+"     a="+a+"   b="+b)
        return nim_mult((ftpp*3)/2, nim_mult(a/ftpp, b/ftpp));
    }

   def nim_mult_slow(a:Int,b:Int) = {
   // This function multiplies two nim values
   // Nim multiplication is defined recursively, so I have created an array of values and use those to build up to the desired value

   // Determine the max of a and b, then create a square array of that size
   var d = Math.max(a,b)

   var g:Array[Array[Int]] =  Array.fill(d+1, d+1)(-1)
 //  for(i <- 0 to d) {
 //    g(i) = new Array(d+1)
 //  }

 //  // Initialize the entire matrix as "-1"...this is used later to determine if we need to compute an entry or not
 //  for(i <- 0 to d) {
 //    for(j <- 0 to d) {
 //      g(i)(j)="-1"
 //    }
 //  }

   // Initialize the first two rows/columns of the matrix
   for(i <- 0 to d) {
     g(i)(0) = 0
     if(b>0)
       g(i)(1) = i
   }
   for(j <- 0 to d) {
     g(0)(j) = 0
     if(a>0)
       g(1)(j) = j
   }

   // Recursively determine the remaining values in the matrix
   for(m <- 2 to a) {
     for(n <- 2 to b) {
       // This helps to reduce the amount of calculations (it does a better reduction when a and b are close)
       if(g(m)(n) == -1) {
	 var nim_mult_list:List[Int] = Nil
	 for(k <- 0 to m-1) {
	   for(l <- 0 to n-1) {
	     var tmp_num = (g(m)(l))^(g(k)(n))^(g(k)(l))
             nim_mult_list = tmp_num :: nim_mult_list
	   }
	 }
	 g(m)(n) = mex(nim_mult_list)
	 g(n)(m) = g(m)(n)
       }
     }
   }
   // Return the desired multiplication value
   g(a)(b)
 }

   def allComb(limit:Int, W:List[Int]) = {
     var WW:Set[Int] = Set()
     for (w <- W)
       WW = WW + w

//     println("Start ="+W)

     for (w <- W) {
       breakable {
 //        println("   w= "+w)
	 if (w == 1)
	    break
	 for (ww <- W) {
 //          println("       ww= "+ww)
	   breakable {
	     if (ww == 1)
	       break
	     var newww:Int = w+ww
	     while (newww <= limit) {
	       if (!(WW contains newww))
		 WW = WW + newww
	       newww += w
	       break
	     }
	   }
	 }
       }
     }
     WW.toList.sortWith((x, y) => x < y)
   }

   def generate(limit:Int) = {
     var W:List[Int] = Nil
     var H:List[Int] = Nil

     breakable { 
       for (i <- 1 to 2*limit) {
	 val w = i*i
	 if (w <= limit)
	   W = w :: W
	 val h = (i*(i+1))/2
	 if (h > limit) 
	   break
	 H = h :: H
      }
    }
 
 //   Array(allComb(limit,W.sortWith((x, y) => x < y)),H.sortWith((x, y) => x < y))
 //   Array(W.sortWith((x, y) => x < y),H.sortWith((x, y) => x < y))
 //    Array(allComb(limit,W.sortWith((x, y) => x < y)).sortWith((x, y) => x < y), allComb(limit,H.sortWith((x, y) => x < y)).sortWith((x, y) => x < y))
 //   Array(List(1, 
 //              4,  8, 12,   20, 24, 28, 32,   40, 44, 48, 52, 56, 60,   68, 72, 76, 80, 84, 88, 92, 96, 
 //              9, 18, 27,   45, 54, 63, 72, 99,
 //             16, 
 //             25, 29, 34, 41,
 //             36, 63,
 //             49, 53, 58, 65,
 //             64, 73, 91,
 //             81, 85, 89,
 //             100).sortWith((x, y) => x < y), 

 //   Array(List(1, 
 //              4,  8, 
 //              9, 13,
 //             16, 20,
 //             25, 29, 34,
 //             36, 40, 45,
 //             49, 53, 58, 65,
 //             64, 68, 73, 80,
 //             81, 85, 89, 96,
 //             100).sortWith((x, y) => x < y), 

 //   Array(List(1, 
 //              4,  8, 13, 20, 29, 40, 53, 68, 85, 
 //              9,     18, 34, 45, 58, 73, 90,
 //             16,         32, 41, 52, 65, 80,
 //             25,             50, 61, 74, 89,
 //             36,                 72, 85,
 //             49,                     98,
 //             64, 
 //             81, 
 //             100).sortWith((x, y) => x < y), 

 //   Array(List(1, 
 //              4,
 //              9, 13,
 //             16, 20,
 //             25, 29, 34, 41,
 //             36, 40, 45, 52, 61,
 //             49, 53, 58, 65, 74, 85,
 //             64, 68, 73, 80, 89,
 //             81, 85, 96,
 //             100).sortWith((x, y) => x < y), 

 //   Array(List(1, 
 //              4,  8,
 //              9, 13, 18,
 //             16, 20,     32, 
 //             25, 29, 34, 41, 50,
 //             36, 40, 45, 52, 61, 72,
 //             49, 53, 58, 65, 74, 85, 98,
 //             64, 68, 73, 80, 89,
 //             81, 85, 96,
 //             100).sortWith((x, y) => x < y), 

 //   Array(List(1, 
 //              4,  8,
 //              9, 13, 18,
 //             16, 20,     32, 
 //             25, 29, 34, 41, 50,
 //             36, 40, 45, 52, 61, 72,
 //             49, 53, 58, 65, 74, 85, 98,
 //             64, 68, 73, 80, 89,
 //             81, 85, 96,
 //             100).sortWith((x, y) => x < y), 

 //   Array(List(1, 4, 9, 16, 25, 36, 49, 64, 81, 100),
 //        List(1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91)
 //        )


//    4,  8, 12, 16, 17, 21, 25, 29, 32, 34, 36, 40, 44, 48, 52, 53, 57, 61, 65, 68, 70, 72, 76, 80, 84, 88, 92, 96, 97
//    6, 12, 15, 21, 27, 30, 36, 42, 45*, 51, 57, 60, 66, 72, 75, 81, 87, 90, 93, 99

 //   Array(List(1-1, 4-1, 9-1, 16-1, 25-1, 36-1, 49-1, 64-1, 81-1, 100-1),
 //        List(1-1, 3-1, 6-1, 10-1, 15-1, 21-1, 28-1, 36-1, 45-1, 55-1, 66-1, 78-1, 91-1)
 //        )

      Array(W.reverse,H.reverse)
  }

   def sum(limit:Int, A:Array[List[Int]]) = {
     var sum:Int = 0
     for( i <- 0 to A(0).length-1 ) {
       var w = A(0)(i)
       for( j <- 0 to A(1).length-1 ) {
	 var h = A(1)(j)
	 if (w > 1) {
 //        if (w > h) {
	   for (k <- 0 to limit-1) { // A(0).length-1) {
	     if ((k%w==0) && ((h*w - limit)%2 == 0)) { // if (((h)%2) - ((A(0)(k))%2)!=0 ) { // if ((h*A(0)(k))%2 == 0) { // if (h <= A(0)(k) || ((h*A(0)(k))%2 != 0)) { // if (((limit-h)*(limit-A(0)(k)))%2 == 0) {    // if ((h*A(0)(k))%2 == 0) {
	       // println("Adding "+(limit-h+1))
	       sum += (limit-h+1)
	     }
	   }
	 }
       }
     }
     sum
  }

   def getRanges(S:List[Int], V:Array[Int]):Array[Int] = {
      var nRanges:Array[Int] =  Array.fill(V.length+1)(0)
      var ranges:Array[Int] =  Array.fill(V.length+1)(0)
      ranges(0) = 0;
      for (n <- 1 to V.length) {
         ranges(n) = ranges(n-1)^V(n-1)
         for (s <- S) {
            //              System.out.println("nRanges["+(ranges[n]^ranges[n-k])+"]++  (ranges["+n+"]="+ ranges[n] + "  ranges["+(n-k)+"]="+ranges[n-k] +")");
               if (s<=n)
	         nRanges((ranges(n)^ranges(n-s))) += 1
         }
//	 for (i<-0 to ranges.length-1) {
//          if (ranges(i) != 0)
//            println("ranges["+i+"]="+ ranges(i))
//         }
      }
//      for (i<-0 to nRanges.length-1) {
//         if (nRanges(i) != 0)
//            println("nRanges["+i+"]="+ nRanges(i))
//     }

      nRanges
    }


   def findCount(limit:Int, tot:Long, A:Array[List[Int]], R:Array[Int], C:Array[Int]):Long = {

      var nCol:Array[Int] = getRanges(A(0), R)
      var nRow:Array[Int] = getRanges(A(1), C)

      var count:Long = 0
      println("Calculating Solutions")
      for (i <- 1 to limit-1) {
//          if (i%10000==0) System.out.println("  calculating solutions for i="+i);
         if (nRow(i) > 0) {
            for (j <- 1 to limit-1) {
               if (nCol(j) > 0) {
                  if (tot == nim_mult(i,j)) {
                     var prod:Long = nRow(i)*nCol(j)
                     println("i="+i+" j="+j+"  "+nRow(i)+" * "+ nCol(j) + " = " + prod + "   (total="+(count+prod)+")");
                     if (prod > 0)
                        count += prod
                  }
               }
            }
         }
      }
      count
   } 
   

   def puzzle_459(limit:Int) = {
//     println("Started 459")
//     var limit = 10 // 5 // 100 // 1000000
//    println("limit="+limit)
        
//    println("Generating main row and column vectors")
    val A = generate(limit)
//    println("W="+A(0))
//    println("H="+A(1))
    var R = row(limit,A(0))
    var C = row(limit,A(1))
//    var R = row(limit,List(1,2,3,4,5,6,7,8,9,10))
//    var C = row(limit,List(1,2,3,4,5,6,7,8,9,10))
//    println("R=")
//    for (i <- 0 to R.length-1)
//      print(R(i)+" ")
//   println()
//    println("C=")
//    for (i <- 0 to C.length-1)
//      print(C(i)+" ")
//    println()

//    println("Generating matrix M")
    var tot:Long = 0
//    var M:Matrix = matrix(C.reverse,R)    // reversing so that the C(0) shows the bottom
//    M(0)(2) = 0
//    M(1)(2) = 0
//    M(2)(2) = 0
//    println("M=")
//    for (i <- 0 to R.length-1) {
//      for (j <- 0 to R.length-1) {
//         print(M(i)(j)+" ")
//         tot = nim_sum(tot, M(i)(j))
//      }
//      println()
//    }
//    println()

    var totRow = 0;
    for (r <- R)
      totRow ^= r;
    var totCol = 0;
    for (c <- C)
      totCol ^= c;
    tot = nim_mult(totRow, totCol)
    println("nim_sum(M)="+tot)

    var count:Long = findCount(limit, tot, A, R, C)
      
//    val result = sum(limit, A)
//    println("result ="+count+"  (expected=31395)")
    Array(count,tot)
  }

  def main(args: Array[String]) {
     var limit= 1000000 // 100 // 1000000
     println("W("+limit+")="+puzzle_459(limit)(0))
/*
     var Res = Array.fill(limit)(0)
     var Tot  = Array.fill(limit)(0)
     for (i <- 1 to limit) {
        var A = puzzle_459(i)
        Res(i-1) = A(0)
        Tot(i-1) = A(1)
     }
     for (i <- 1 to limit)
       println("W("+i+")="+Res(i-1)+"  Tot="+Tot(i-1))
*/

  }

}


/*

the rectangle width is a perfect square (1, 4, 9, 16, ...)
the rectangle height is a triangular number (1, 3, 6, 10, ...)

ooooo
ooooo
ooooo
ooooo
ooooo

25 1x1
10 1x4
15 3x1
6  3x4

GOOD:

oooxo    ooooo    ooooo           ooooo    ooooo           oooxo      ooooo      ooooo    
ooooo    oooxo    ooooo           ooooo    ooooo           oooxo      oooxo      ooooo    
ooooo    ooooo    oooxo           ooooo    ooooo           oooxo      oooxo      oooxo    
ooooo    ooooo    ooooo           oooxo    ooooo           ooooo      oooxo      oooxo    
ooooo    ooooo    ooooo           ooooo    oooxo           ooooo      ooooo      oooxo    

24 1x1                            24 1x1                   22 1x1
9  1x4                            9  1x4                   7  1x4
14 3x1                            15 3x1                   12 3x1     13 3x1     14 3x1 
5  3x4                            6  3x4                   3  3x4     4  3x4     5  3x4     


BAD:

oooox    ooooo    ooooo           ooooo    ooooo           oooox      ooooo      ooooo    
ooooo    oooox    ooooo           ooooo    ooooo           oooox      oooox      ooooo    
ooooo    ooooo    oooox           ooooo    ooooo           oooox      oooox      oooox    
ooooo    ooooo    ooooo           oooox    ooooo           ooooo      oooox      oooox    
ooooo    ooooo    ooooo           ooooo    oooox           ooooo      ooooo      oooox    

24 1x1                            24 1x1                   22 1x1
9  1x4                            9  1x4                   7  1x4
14 3x1                            15 3x1                   12 3x1     13 3x1     14 3x1
5  3x4                            6  3x4                   3  3x4     4  3x4     5  3x4


ooxoo    ooooo    ooooo           ooooo    ooooo           ooxoo      ooooo      ooooo    
ooooo    ooxoo    ooooo           ooooo    ooooo           ooxoo      ooxoo      ooooo    
ooooo    ooooo    ooxoo           ooooo    ooooo           ooxoo      ooxoo      oxooo    
ooooo    ooooo    ooooo           ooxoo    ooooo           ooooo      ooxoo      oxooo    
ooooo    ooooo    ooooo           ooooo    ooxoo           ooooo      ooooo      oxooo    

24 1x1                            24 1x1                   22 1x1
10 1x4                            10 1x4                   10 1x4
14 3x1                            15 3x1                   12 3x1     13 3x1     14 3x1
6  3x4                            6  3x4                   6  3x4

W = 1, 4, 9, 16, 25, 36, 49, 64, 81, 100
L = 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91
100 + (100-3) + (100-6) + (100-10) + (100-15) + (100-21) + (100-28) + (100-36) + (100-45) + (100-55) + (100-66) + (100-78) + (100-91) = 945?  858

10 + 120 + 210 + 1      =?     31395

ooooo
ooooo
ooooo
oxoxx
oooxo

24 1x1
9  1x4
15 3x1
6  3x4

ooxoo
ooooo
ooooo
ooooo
ooooo

24 1x1
10 1x4
14 3x1
6  3x4





xxxxx
xxxxx
xxxxx
xxxxx
xxxox

xxxxx
xxxxx
xxxxx
xxxxx
oooox


xxxxx
xxxxx
xxxxx
xxxxx
oooox



*/