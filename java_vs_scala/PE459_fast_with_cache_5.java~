import java.util.ArrayList;
import java.util.Collections;
import java.util.Arrays;
import java.io.PrintWriter;
import java.io.BufferedReader;
import java.io.FileReader;

class PE459_fast_with_cache_5 {

    public static boolean debug = false;
    static boolean readFromFile = false;
    static boolean fastNimMult = true;

    static int[] row(int limit, ArrayList<Integer> V) {
//    print("Using V=")
//    for (i <- 0 to V.length-1)
//      print(V(i)+" ")
//    System.out.println()

	int[] R = new int[limit];
        R[0] = 1;
        int[] last = {1};
	for(int i=1; i < limit; i++) {
//	    if ((i+1)%100000==0) System.out.println("Generating row i="+(i+1));
	    int[] cache = new int[V.size()];
	    ArrayList<Integer> mexList = new ArrayList<Integer>();
	    mexList.add(0);
	    for (int k=0; k < V.size(); k++) {
		if (V.get(k) > i+1)
		    break;
		if (debug) System.out.println("Computing i="+i+"  V("+k+")="+V.get(k));
		int tmp_num = 0;
		if (V.get(k) == i+1) {               // starting a new size 
		    if (debug) System.out.println("Starting a new size="+V.get(k));
                    tmp_num = cache[k-1];             // use the last longest entry
		    if (debug) System.out.println("  tmp_num="+tmp_num);
		    for(int t=i-V.get(k)+1; t < i-V.get(k-1)+1; t++) {
			tmp_num ^= R[t];
			if (debug) System.out.println("  Referenced i="+i+"  in R("+t+")="+R[t]+"   tmp_num="+tmp_num);
		    }
		} else if (V.get(k) > 1) {
		    tmp_num = last[k];
		    if (debug) System.out.println("  tmp_num="+tmp_num);
		    tmp_num ^= R[i-V.get(k)];       // remove the first entry from last time
		    if (debug) System.out.println("  tmp_num="+tmp_num);
		    tmp_num ^= R[i-1];              // add the new entry
		}
		if (debug) System.out.println("final tmp_num="+tmp_num);
		//	      System.out.println("tmp_num="+tmp_num);
		mexList.add(tmp_num);
		cache[k] = tmp_num;
	    }
	    int r = mex(mexList);
	    if (debug) System.out.println("nim_mult_str="+mexList+"  R("+i+") = "+r);
	    R[i] = r;
	    last = cache;
	}
	return R;
    }

    static int[][] matrix(int[] Row, int[] Col, int[][] M) {
//	for(int i=0; i < Row.length; i++) {
//	    for(int j=0; j < Col.length; j++) {
//		M[i][j] = nim_mult(Row[i], Col[j]);
//	    }
//	}

	for(int i=0; i < Row.length; i++) {
	    if ((i+1)%1000==0) System.out.println("Generating matrix i="+(i+1));
            int k=0;
	    for(  ; k < i; k++) {
		if (Row[i]==Row[k]) {
		    break;
		}
	    }
	    if (k==i) {  // no match found
		for(int j=0; j < Col.length; j++) {
		    M[i][j] = (int)nim_mult(Row[i], Col[j]);
		}
	    } else {
//		System.out.print("Match found:");
		for(int j=0; j < Col.length; j++) {  // copy over previous values
//		    System.out.print(M[k][j]+" ");
		    M[i][j] = M[k][j];
		}
	    }
	    if (debug) System.out.println();
	}
	if (debug) System.out.println();

	return M;
    }

    static int nim_sum(int a, int b) {
	return a^b;   // Computes binary XOR
    }

    static int mex(ArrayList<Integer> input) {
	// This function takes an input list of numbers and returns the mex value of those numbers
	// That is, the function returns the minimal exluded value (the smallest number, from 0, not in the list)
	// e.g. mex(List(0, 1, 3)) = 2   while   mex(List(0, 1, 2)) = 3 and mex(List(1, 2, 3)) = 0

	// use the array like a hash
	int[] numArr = new int[input.size()];

	//	System.out.print("Mex input List =");
	for (int i=0; i < input.size(); i++) {
	    //            System.out.print(input.get(i));
	    if (input.get(i) < input.size())     // no need to store large numbers
		numArr[input.get(i)] = 1;
	    //        print(numArr[i]+" ")
	}
	//	System.out.println();

	// Define n to be the largest number in our array
	int mexValue = -1;

	// Look for the numbers 0, 1, ..., n in the list of numbers
	// If any of those numbers are not in there, that is the mex value
	// If every number is contained in there, then the mex value is n+1
	for(int i=0; i < numArr.length; i++) {
	    if(numArr[i] != 1) {
		mexValue = i;
		break;
	    } else {
		mexValue = i+1;
	    }
	}
	return mexValue;
    }

    static int[][] nim_mult_cache;
    static long max_queried_nim_mult_cache = -2;


    static int nim_mult_partial(int a, int b) {
        max_queried_nim_mult_cache = Math.max(max_queried_nim_mult_cache, Math.max(a,b));
        if ((a >= nim_mult_cache.length) || (b >= nim_mult_cache[0].length)) {
    //            System.out.println("Extending nim_mult_cache to ("+a+","+b+")");
	    return nim_mult_slow(a,b);
	}

	return nim_mult_cache[a][b];
    }

    
    static long nim_mult(long a, long b) {
        max_queried_nim_mult_cache = Math.max(max_queried_nim_mult_cache, Math.max(a,b));

        if ((a < nim_mult_cache.length) && (b < nim_mult_cache[0].length)) {
	    if (nim_mult_cache[(int)a][(int)b] != -1)
		return (long)nim_mult_cache[(int)a][(int)b];
	}
	    
	long result = fastNimMult ? nim_mult_fast(a,b) : nim_mult_slow((int)a,(int)b) ;
        if ((a < nim_mult_cache.length) && (b < nim_mult_cache[0].length)) {
	    nim_mult_cache[(int)a][(int)b] = (int)result;
	}

	return result;
    }

/*
const ll ftp[6]={1ll<<1,1ll<<2,1ll<<4,1ll<<8,1ll<<16,1ll<<32}; // Fermat two-powers (2^(2^n))
ll nim_mul(ll x, ll y) {
  if (x>y) { // enforce x<=y
    ll t=x;
    x=y,y=t;
  }

  if (x==0) return 0;
  if (x==1) return y;

  ll ftpp=0; // Fermat two-power previous to y
  for (int i=0; i<sizeof(ftp)/sizeof(const ll); i++)
    if (ftp[i]==y) { // if y is a Fermat two-power use a rule
      if (x==y)
   return x*3/2;
      else
   return x*y;
    }
    else if (ftp[i]<y)
      ftpp=ftp[i];

  for (ll yy=1; yy<y; yy*=2)
    if (y&yy) // if y isn't a power of two reduce by distributive law
      return nim_mul(yy,x)^nim_mul(x,y-yy);
  if (x%ftpp) // avoid infinite recursion
    return nim_mul(ftpp,nim_mul(x,y/ftpp));
  return nim_mul(ftpp*3/2,nim_mul(x/ftpp,y/ftpp));
}
*/

    // Fermat two-powers (2^(2^n))
    static final long[] ftp = { 1L<<1, 1L<<2, 1L<<4, 1L<<8, 1L<<16, 1L<<32 }; 

    static long nim_mult_fast(long a, long b) {
	if (a>b) { // enforce a<=b
	    long t=a;
	    a=b;
	    b=t;
	}

	if (a==0) return 0;
	if (a==1) return b;

	long ftpp=0; // Fermat two-power previous to b
	for (int i=0; i < ftp.length; i++) {
	    if (ftp[i]==b) { // if b is a Fermat two-power use a rule
		if (a==b)
		    return 3*a/2;
		else
		    return a*b;
	    }
	    else if (ftp[i]<b)
		ftpp=ftp[i];
	}
	for (long bb=1; bb<b; bb*=2) {
	    if ((b&bb) != 0) // if b isn't a power of two reduce by distributive law
		return nim_mult(bb,a)^nim_mult(a, b-bb);
	}
	
	if (a%ftpp != 0) // avoid infinite recursion
	    return nim_mult(ftpp, nim_mult(a, b/ftpp));

	return nim_mult(ftpp*3/2, nim_mult(a/ftpp, b/ftpp));
    }

    static int nim_mult_slow(int a, int b) {
	// This function multiplies two nim values                                                                                                                                                 
        // Nim multiplication is defined recursively, so I have created an array of values and use those to build up to the desired value                                                          

	    // Determine the max of a and b, then create a square array of that size                                                                                                                   
	    int d = Math.max(a,b);

	    int[][] g =  new int[d+1][d+1];
	    for (int[] row : g)
		Arrays.fill(row, -1);  // Initialize the entire matrix as "-1"...this is used later to determine if we need to compute an entry or not                                                 
	    //  for(i <- 0 to d) {                                                                                                                                                                     
	    //    for(j <- 0 to d) {                                                                                                                                                                   
	    //      g[i][j]="-1"                                                                                                                                                                       
	    //    }                                                                                                                                                                                    
	    //  }                                                                                                                                                                                      

	    // Initialize the first two rows/columns of the matrix                                                                                                                                     
	    for (int i=0; i <= d; i++) {
		g[i][0] = 0;
		if (b>0)
		    g[i][1] = i;
	    }
	    for (int j=0; j <= d; j++) {
		g[0][j] = 0;
		if(a>0)
		    g[1][j] = j;
	    }

	    // Recursively determine the remaining values in the matrix                                                                                                                                
	    for(int m=2; m <= a; m++) {
		for(int n=2; n <= b; n++) {
		    // This helps to reduce the amount of calculations (it does a better reduction when a and b are close)                                                                             
		    if (g[m][n] == -1) {
			ArrayList<Integer> nim_mult_list = new ArrayList<Integer>();
			for(int k=0; k < m; k++) {
			    for(int l=0; l < n; l++) {
				int tmp_num = (g[m][l])^(g[k][n])^(g[k][l]);
				nim_mult_list.add(tmp_num);
			    }
			}
			g[m][n] = mex(nim_mult_list);
			g[n][m] = g[m][n];
		    }
		}
	    }
            nim_mult_cache = g;

        return nim_mult_cache[a-1][b-1];
    }

    static int nim_mult_generate(int a, int b) {
	// This function multiplies two nim values
	// Nim multiplication is defined recursively, so I have created an array of values and use those to build up to the desired value

	//	if ( (a < nim_mult_cache.length) && (b < nim_mult_cache[0].length) && (nim_mult_cache[a-1][b-1] != -1) ) 
	//	    return nim_mult_cache[a-1][b-1];

	// Determine the max of a and b, then create a square array of that size
	int d = Math.max(a,b);

//	nim_mult_cache =  new int[d+1][d+1];
//	for (int[] row : nim_mult_cache)
//	    Arrays.fill(row, -1);  // Initialize the entire matrix as "-1"...this is used later to determine if we need to compute an entry or not
	//  for(i <- 0 to d) {
	//    for(j <- 0 to d) {
	//      nim_mult_cache[i][j]="-1"
	//    }
	//  }

	// Initialize the first two rows/columns of the matrix
	for (int i=0; i <= d; i++) {
	    nim_mult_cache[i][0] = 0;
	    if (b>0)
		nim_mult_cache[i][1] = i;
	}
	for (int j=0; j <= d; j++) {
	    nim_mult_cache[0][j] = 0;
	    if(a>0)
		nim_mult_cache[1][j] = j;
	}

	// Recursively determine the remaining values in the matrix
	for(int m=2; m <= a; m++) {
            if (m%10==0) System.out.println("  nim_matrix computing row "+m);
	    for(int n=2; n <= b; n++) {
		// This helps to reduce the amount of calculations (it does a better reduction when a and b are close)
		if (nim_mult_cache[m][n] == -1) {
		    ArrayList<Integer> nim_mult_list = new ArrayList<Integer>();
		    for(int k=0; k < m; k++) {
			for(int l=0; l < n; l++) {
			    int tmp_num = (nim_mult_cache[m][l])^(nim_mult_cache[k][n])^(nim_mult_cache[k][l]);
			    nim_mult_list.add(tmp_num);
			}
		    }
		    nim_mult_cache[m][n] = mex(nim_mult_list);
		    nim_mult_cache[n][m] = nim_mult_cache[m][n];
		}
		//                nim_mult_cache[n][m] = nim_mult_cache[m][n];
		//		nim_mult_cache[m][n] = nim_mult_cache[n][m];
	    }
	}

	//	if ( (a < nim_mult_cache.length) && (b < nim_mult_cache[0].length)) {
	    //	    nim_mult_cache[a-1][b-1] = nim_mult_cache[a][b];
	    //	    nim_mult_cache[b-1][a-1] = nim_mult_cache[a][b];
	//	}

	// Return the desired multiplication value
	return nim_mult_cache[a][b];
    }

   static ArrayList<ArrayList<Integer>> generate(int limit) {

       ArrayList<Integer> W = new ArrayList<Integer>();
       ArrayList<Integer> H = new ArrayList<Integer>();

       for (int i=1; i <= 2*limit; i++) {
	   int w = i*i;
	   if (w <= limit)
	       W.add(w);
	   int h = (i+w)/2;
	   if (h > limit) 
	       break;
	   H.add(h);
       }
 
 //   Array(allComb(limit,W.sortWith((x, y) => x < y)),H.sortWith((x, y) => x < y))
 //   Array(W.sortWith((x, y) => x < y),H.sortWith((x, y) => x < y))
 //    Array(allComb(limit,W.sortWith((x, y) => x < y)).sortWith((x, y) => x < y), allComb(limit,H.sortWith((x, y) => x < y)).sortWith((x, y) => x < y))

 //   Array(List(1, 4, 9, 16, 25, 36, 49, 64, 81, 100),
 //        List(1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91)
 //        )

       ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
//       Collections.reverse(W);
//       Collections.reverse(H);
       result.add(W);
       result.add(H);

       return result;
   }

//	nmap nsrow, nscol;
//	for (ll n=1; n<=N; n++) {
//	    for (ll i=1,k=1; k<=n; i++,k=i*(i+1)/2)
//		nsrow[sgrow[n]^sgrow[n-k]]++;
//	    for (ll i=1,k=1; k<=n; i++,k=i*i)
//		nscol[sgcol[n]^sgcol[n-k]]++;
//	}
//	n is the alignment (end of range), and k is the width or height of the range (square or triangle number). 
//     sgrow/sgcol are accumulated g values along the row or column, using nim-sum to accumulate.
/*
	long[] sgrow = new long[limit+1];
	long[] sgcol = new long[limit+1];

	sgrow[0] = 0; //nim_mult(R[n], C[0]);
	sgcol[0] = 0; //nim_mult(R[0], C[m]);
	for (int n=1; n <= limit; n++) {
	    sgrow[n] = sgrow[n-1] ^ C[n-1];
	    sgcol[n] = sgcol[n-1] ^ R[n-1];
	    for (int i=1,k=1; i < A.get(0).size() && A.get(0).get(i)<=n; i++,k=(i*(i))) {
//		System.out.println("nsrow["+(sgrow[n]^sgrow[n-k])+"]++  (sgrow["+n+"]="+ sgrow[n] + "  sgrow["+(n-k)+"]="+sgrow[n-k] +")");		
		nsrow[(int)(sgrow[n]^sgrow[n-A.get(0).get(i)])]++;
	    }
	    for (int i=1,k=1; i<A.get(1).size() &&  A.get(1).get(i)<=n; i++,k=(i*(i+1))/2) {
//		System.out.println("nscol["+(sgcol[n]^sgcol[n-k])+"]++  (sgcol["+n+"]="+ sgcol[n] + "  sgcol["+(n-k)+"]="+sgcol[n-k] +")");
		nscol[(int)(sgcol[n]^sgcol[n-A.get(1).get(i)])]++;
	    }
	}

//	for (int i=0; i <= limit; i++)
//	    System.out.println("sgrow["+i+"]="+ sgrow[i]);
//
//	for (int i=0; i <= limit; i++)
//	    System.out.println("sgcol["+i+"]="+ sgcol[i]);
//

*/

    static long[] getRanges(ArrayList<Integer> S, int[] V)  {
	long[] nRanges = new long[V.length+1];
	long[] ranges = new long[V.length+1];
	ranges[0] = 0;
	for (int n=1; n <= V.length; n++) {
	    ranges[n] = ranges[n-1]^V[n-1];
	    for (int s : S){
	    //              System.out.println("nRanges["+(ranges[n]^ranges[n-k])+"]++  (ranges["+n+"]="+ ranges[n] + "  ranges["+(n-k)+"]="+ranges[n-k] +")");
		if (s<=n) 
		    nRanges[(int)(ranges[n]^ranges[n-s])]++;
	    }
	    if (debug) {
		for (int i=0; i < ranges.length; i++) {
		    if (ranges[i] != 0)
			System.out.println("ranges["+i+"]="+ ranges[i]);
		}
	    }
	}
	if (debug) {
	    for (int i=0; i < nRanges.length; i++) {
		if (nRanges[i] != 0)
		    System.out.println("nRanges["+i+"]="+ nRanges[i]);
	    }
	}

	return nRanges;
    }

    static long findCount(int limit, long tot, ArrayList<ArrayList<Integer>> A, int[] R, int[] C, int[][] M)  {

	long[] nRow = getRanges(A.get(0), C);
	long[] nCol = getRanges(A.get(1), R);

//	for (int i=0; i <= limit; i++)
//	    if (nRow[i] != 0)
//		System.out.println("nRow["+i+"]="+ nRow[i]);
//
//	for (int i=0; i <= limit; i++)
//	    if (nCol[i] != 0)
//		System.out.println("nCol["+i+"]="+ nCol[i]);

	long count = 0;
	System.out.println("Calculating Solutions");
	for (int i=1; i <= limit; i++) {
//	    if (i%10000==0) System.out.println("  calculating solutions for i="+i);
	    if (nRow[i]==0)
		continue;
	    for (int j=1; j < limit; j++) {
		if (nCol[j] == 0) {
		    continue;
		}
		if (tot == (int)nim_mult(i,j)) {
		    long prod = (long)nRow[i]*(long)nCol[j];
		    System.out.println("i="+i+" j="+j+"  "+nRow[i]+" * "+ nCol[j] + " = " + prod + "   (total="+(count+prod)+")");
		    if (prod > 0) {
			count += prod;
		    }
		}
	    }
	}

	return count;
    }

    static int findCount2(int limit, long tot, ArrayList<ArrayList<Integer>> A, int[] R, int[] C, int[][] M)  {
	      //				    System.out.println("  a="+a+"  b="+b+"   M("+(n-a)+","+(m-b)+")="+M[n-a][m-b]);
	int count = 0;
	int nRows = A.get(1).size();
	int nColumns = A.get(0).size();
	for (int i=0; i < nRows; i++) {         // rows
	    int ARowi = A.get(1).get(i);
	    int lastLarge = 0;
	    System.out.println("findCount processing row "+ A.get(1).get(i));
	    for (int j=0; j < nColumns; j++) {  // columns
		int first = 0;
		int last = 0;
		int AColj = A.get(0).get(j);
		if (debug) System.out.println("Processing rectangle "+ ARowi +" x " + AColj);
		for (int n=ARowi-1; n < limit; n++) {
		    for (int m=AColj-1; m < limit; m++) {
			if (debug) System.out.println("   n="+n+"  m="+m+"   R("+i+")="+ARowi+"    C("+j+")="+AColj);
			int totR = 0;
			if ((n==ARowi-1) && (m==AColj-1)) {   // The first time we are doing the calculation
			    if (j==0) {
				if (debug) System.out.print("First time ever calculation                   totR=0");
				for (int a=0; a < ARowi; a++) {
				    for (int b=0; b < AColj; b++) {
					totR ^= nim_mult(R[n-a], C[m-b]);
//                                        if (debug) System.out.print("^"+M[n-a][m-b]);
				    }
				}
			    } else {
				if (debug) System.out.print("First time calculation                   totR=0^");
				totR ^= lastLarge;
                                if (debug) System.out.print("^"+lastLarge+"(c)");
				for (int a=0; a < ARowi; a++) {
				    for (int b=0; b < A.get(0).get(j)-A.get(0).get(j-1); b++) {
					totR ^= nim_mult(R[n-a], C[m-b]);
//                                        if (debug) System.out.print("^"+M[n-a][m-b]);
				    }
				}				
			    }
			    if (debug) System.out.println(" ="+totR);
			    first = totR;
			    lastLarge = first;
			} else {
			    if (m==AColj-1) {    // starting a new row
				if (debug) System.out.print("   Starting a new row, reusing first=" + first);
				totR = first;
				for (int b=0; b < AColj; b++) {        
				    totR ^= nim_mult(R[n-ARowi],C[m-b]); // remove the old bottom row
				    totR ^= nim_mult(R[n],C[m-b]);       // add the new top row
				}
                                first = totR;
			    } else {             // just moving to next column
				if (debug) System.out.print("      moving to the next column, reusing last=" + last);
				totR = last;
				for (int a=0; a < ARowi; a++) {
				    totR ^= nim_mult(R[n-a],C[m-AColj]); // remove the old left column
				    totR ^= nim_mult(R[n-a],C[m]);       // add the new right column 
				}
			    }
			}
			if (debug) System.out.println("    totR=" + totR);
			if (totR == tot) {
			    count += 1 ;
			    if (debug) System.out.println(count+") Found a solution in region: ("+n+","+m+") for shape ("+ARowi+","+AColj+")   totR="+totR);
			}
			last = totR;
		    }
		}
	    }
	}
	return count;
    }
    
    public static long[] puzzle_459(int limit) {
	System.out.println("======= Started 459 for limit=" + limit + " ========");
	int[][] M =  new int[1][1];
	nim_mult_cache = new int[10000+1][10000+1];
	//	for(int i=0; i < nim_mult_cache.length; i++) {
	//	    for(int j=0; j < nim_mult_cache[0].length; j++) {
	//		nim_mult_cache[i][j] = -1;
	//	    }
	//	}

	for (int[] row : nim_mult_cache)
	    Arrays.fill(row, -1);  // Initialize the entire matrix as "-1"...this is used later to determine if we need to compute an entry or not

        System.out.println("Memory successfully allocated");

        System.out.println("Generating Nim Multiplication table");

	if (readFromFile) {
	    try {
		BufferedReader in = new BufferedReader(new FileReader("Nim_mult.10000.txt.back"));
		nim_mult_cache[0][0] = 0;
		for(int i=1; i < 10000+1; i++) {
		    nim_mult_cache[i][0] = 0;
		    for(int j=1; j <= i; j++) {
			nim_mult_cache[0][j] = 0;
			nim_mult_cache[i][j] = Integer.parseInt(in.readLine());
			nim_mult_cache[j][i] = nim_mult_cache[i][j];
		    }
		}
		in.close();
	    } catch (Exception e) {
		System.out.println("Failed to read file Nim_mult.1000.txt : "+e);
	    }
	}

	//	nim_mult_generate(nim_mult_cache.length-1, nim_mult_cache[0].length-1);

	int maxMinMultValue = -2;
	debug = false;
        if (debug) System.out.println("nim_mult_cache=");
	for(int i=0; i < 11; i++) {
            for(int j=0; j < 11; j++) {
                if (debug) System.out.print(nim_mult_cache[i][j]+" ");
		if (maxMinMultValue < nim_mult_cache[i][j])
		    maxMinMultValue = nim_mult_cache[i][j];
            }
            if (debug) System.out.println();
        }
	if (debug) System.out.println();
	debug = false;

        System.out.println("Done generating Nim Multiplication table  (size = "+nim_mult_cache.length+",max="+maxMinMultValue+")");

	System.out.println("Generating squares and triangle numbers");

	ArrayList<ArrayList<Integer>> A = generate(limit);
	System.out.println("Generating main row and column vectors");

	//	System.out.println("W="+A.get(0));
	//	System.out.println("H="+A.get(1));
	int[] C = row(limit,A.get(0));
	int[] R = row(limit,A.get(1));
	//    var R = row(limit,List(1,2,3,4,5,6,7,8,9,10))
	//    var C = row(limit,List(1,2,3,4,5,6,7,8,9,10))

	debug = false;
	if (debug) {
	    System.out.println("R=");
	    for(int i=0; i < R.length; i++) {
		System.out.print(R[i]+" ");
	    }
	    System.out.println();
	    System.out.println("C=");
	    for(int i=0; i < C.length; i++) {
		System.out.print(C[i]+" ");
	    }
	    System.out.println();
	}
	debug = false;

	// reversing so that the R[0] shows the bottom (this is just for convenience in visualizing)
	if (false) {
	    for(int i=0; i < R.length/2; i++) {
		int temp = R[i]; 
		R[i] = R[R.length - i - 1]; 
		R[R.length - i - 1] = temp; 
	    }
	}

//      No need to generate M anymore, takes a lot of space
//      System.out.println("Generating matrix M")
//	matrix(R,C,M); 

        System.out.println("Calculating the score of the full matrix");

	long tot = 0;
	if (true) { //	if (limit==1000000) {
//	    tot = 6303;
	    long totRow = 0;
	    for (int r : R)
		totRow ^= r;
	    long totCol = 0;
	    for (int c : C)
		totCol ^= c;
	    tot = nim_mult(totRow, totCol);
//	} else if (limit==100000) {
//	    tot = 186;
//	} else if (limit==10000) {
//	    tot = 32;
	} else {
	    int[] totCache = new int[R.length];
	    Arrays.fill(totCache, -1);

	    for(int i=0; i < R.length; i++) {
		if ((i+1)%10000==0) System.out.println("  calculating row "+(i+1));
		if (totCache[i] == -1) {
		    int totRow = 0;
		    for(int j=0; j < C.length; j++) {
			totRow ^= nim_mult(R[i], C[j]);
		    }
		    totCache[i] = totRow;
		}
		tot ^= totCache[i];
	    }
	}

	System.out.println("nim_sum["+limit+"]="+tot);

	//    System.out.println("Finding solutions")
//	int count = (tot==0) ? 0: findCount(limit, tot, C, R, M);
	long count = findCount(limit, tot, A, R, C, M);



	//    val result = sum(limit, A)
	//    System.out.println("result ="+count+"  (expected=31395)")
	System.out.println("W("+limit+")="+count+"  Tot="+tot);
	long[] result = {count, tot};
        return result;
    }

    public static void printStatistics(long startTime) {
	long endTime = System.currentTimeMillis();
	Runtime rt = Runtime.getRuntime();
	long memory = (rt.totalMemory() - rt.freeMemory()) / 1024;
	System.out.println("\nProgram ran in " + (endTime-startTime)/1000 + " seconds, using " + memory + " kbytes of memory");
    }

    public static void main(String[] args) {
	int limit= 1000000; // 100 // 1000000
        // Expected  W(100)=31395 (tot=7,0sec)       W(300)=907144   (tot=11, 2sec)          W(500)=72702             (tot=43, 20sec)      
	// W(1000)=1869203  (tot=53, 393sec)         W(10000)=2477885152 (tot=32, sec)       W(100000)=2475200726993 34673946766    (tot=186, sec)
        // W(1000000)=3996390106631    (tot=6303, sec)

        long startTime = System.currentTimeMillis();
	System.out.println("W("+limit+")="+puzzle_459(limit)[0]);

	System.out.println("max_queried_nim_mult_cache="+max_queried_nim_mult_cache);

	int nonNull = 0;
        try {
            PrintWriter out = new PrintWriter("Nim_mult.10000.txt");
            for(int i=1; i < nim_mult_cache.length; i++) {
                for(int j=1; j <= i; j++) {
		    if (nim_mult_cache[i][j] != -1)
			nonNull++;
                    out.println(nim_mult_cache[i][j]);
                }
            }
            out.close();
        } catch (java.io.FileNotFoundException e) {
            System.out.println("File not found");
        }

	System.out.println("Written out the nim-mult matrix with 50005000 entries ("+nonNull+" of them are nontrivial, i.e. != -1)");

/*
	int[] Res = new int[limit];
	int[] Tot = new int[limit];
	for (int i=5; i <= limit; i++) {
	    int[] A = puzzle_459(i);
	    Res[i-1] = A[0];
	    Tot[i-1] = A[1];
	}
	for (int i=1; i <= limit; i++) {
	    System.out.println("W("+i+")="+Res[i-1]+"  Tot="+Tot[i-1]);
	}
*/
        printStatistics(startTime);
    }

}

/*

the rectangle width is a perfect square (1, 4, 9, 16, ...)
the rectangle height is a triangular number (1, 3, 6, 10, ...)

ooooo
ooooo
ooooo
ooooo
ooooo

25 1x1
10 1x4
15 3x1
6  3x4

GOOD:

oooxo    ooooo    ooooo           ooooo    ooooo           oooxo      ooooo      ooooo    
ooooo    oooxo    ooooo           ooooo    ooooo           oooxo      oooxo      ooooo    
ooooo    ooooo    oooxo           ooooo    ooooo           oooxo      oooxo      oooxo    
ooooo    ooooo    ooooo           oooxo    ooooo           ooooo      oooxo      oooxo    
ooooo    ooooo    ooooo           ooooo    oooxo           ooooo      ooooo      oooxo    

24 1x1                            24 1x1                   22 1x1
9  1x4                            9  1x4                   7  1x4
14 3x1                            15 3x1                   12 3x1     13 3x1     14 3x1 
5  3x4                            6  3x4                   3  3x4     4  3x4     5  3x4     


BAD:

oooox    ooooo    ooooo           ooooo    ooooo           oooox      ooooo      ooooo    
ooooo    oooox    ooooo           ooooo    ooooo           oooox      oooox      ooooo    
ooooo    ooooo    oooox           ooooo    ooooo           oooox      oooox      oooox    
ooooo    ooooo    ooooo           oooox    ooooo           ooooo      oooox      oooox    
ooooo    ooooo    ooooo           ooooo    oooox           ooooo      ooooo      oooox    

24 1x1                            24 1x1                   22 1x1
9  1x4                            9  1x4                   7  1x4
14 3x1                            15 3x1                   12 3x1     13 3x1     14 3x1
5  3x4                            6  3x4                   3  3x4     4  3x4     5  3x4


ooxoo    ooooo    ooooo           ooooo    ooooo           ooxoo      ooooo      ooooo    
ooooo    ooxoo    ooooo           ooooo    ooooo           ooxoo      ooxoo      ooooo    
ooooo    ooooo    ooxoo           ooooo    ooooo           ooxoo      ooxoo      oxooo    
ooooo    ooooo    ooooo           ooxoo    ooooo           ooooo      ooxoo      oxooo    
ooooo    ooooo    ooooo           ooooo    ooxoo           ooooo      ooooo      oxooo    

24 1x1                            24 1x1                   22 1x1
10 1x4                            10 1x4                   10 1x4
14 3x1                            15 3x1                   12 3x1     13 3x1     14 3x1
6  3x4                            6  3x4                   6  3x4

W = 1, 4, 9, 16, 25, 36, 49, 64, 81, 100
L = 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91
100 + (100-3) + (100-6) + (100-10) + (100-15) + (100-21) + (100-28) + (100-36) + (100-45) + (100-55) + (100-66) + (100-78) + (100-91) = 945?  858

10 + 120 + 210 + 1      =?     31395

ooooo
ooooo
ooooo
oxoxx
oooxo

24 1x1
9  1x4
15 3x1
6  3x4

ooxoo
ooooo
ooooo
ooooo
ooooo

24 1x1
10 1x4
14 3x1
6  3x4





xxxxx
xxxxx
xxxxx
xxxxx
xxxox

xxxxx
xxxxx
xxxxx
xxxxx
oooox


xxxxx
xxxxx
xxxxx
xxxxx
oooox



*/